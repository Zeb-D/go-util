package main

import (
	"fmt"
	"reflect"
)

//这里主要研究golang的内存逃逸

//golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全 可知。
// 如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在 堆上分配。
//能引起变量逃逸到堆上的典型情况:
// 在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但是由 于返回时被外部引用，因此其生命周期大于栈，则溢出。
// 发送指针或带有指针的值到 channel 中。 在编译时，是没有办法知道哪
//个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会 被释放。
// 在一个切片上存储指针或带指针的值。 一个典型的例子就是 []*string 。
// 这会导致 切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在 堆上。
// slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。
// slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。
// 如果切片背后的存 储要基于运行时的数据进行扩充，就会在堆上分配。
// 在 interface 类型上调用方法。 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。
// 想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配

type A struct {
	s string
}

// 这是上面提到的 "在方法内把局部变量指针返回" 的情况
func foo(s string) *A {
	a := new(A)
	a.s = s
	return a //返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆
}

//go build -gcflags=-m main.go
func main() {
	a := foo("hello")
	b := a.s + " world"
	c := b + "!"
	fmt.Println(c) //这个fmt参数是个interface，所以c会逃逸到堆上
	//reflect.ValueOf //逃逸到堆意味着将值拷贝一份到堆上
	var aa = "xxx"
	_ = reflect.ValueOf(&aa)

	var bb = "xxx2"
	_ = reflect.TypeOf(&bb)
}

//➜  main git:(master) ✗ go build -gcflags=-m gcflags_main.go
//# command-line-arguments
//./gcflags_main.go:26:6: can inline foo
//./gcflags_main.go:34:10: inlining call to foo
//./gcflags_main.go:37:13: inlining call to fmt.Println
//./gcflags_main.go:26:10: leaking param: s
//./gcflags_main.go:27:10: new(A) escapes to heap
//./gcflags_main.go:34:10: main new(A) does not escape
//./gcflags_main.go:35:11: main a.s + " world" does not escape
//./gcflags_main.go:36:9: b + "!" escapes to heap
//./gcflags_main.go:37:13: c escapes to heap
//./gcflags_main.go:37:13: main []interface {} literal does not escape
//./gcflags_main.go:37:13: io.Writer(os.Stdout) escapes to heap
//<autogenerated>:1: (*File).close .this does not escape

//磨刀（逃逸分析工具）：
//分析工具:
//
//1.通过编译工具查看详细的逃逸分析过程(go build -gcflags '-m -l' main.go)
//2.通过反编译命令查看go tool compile -S main.go
//其中 编译参数(-gcflags)介绍:
//
//-N: 禁止编译优化
//
//-l: 禁止内联(可以有效减少程序大小)
//
//-m: 逃逸分析(最多可重复四次)
//
//-benchmem: 压测时打印内存分配统计
